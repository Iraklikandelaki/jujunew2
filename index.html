<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing - unreal bloom selective</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		
		<script id="vertexShader2" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 vPosition;
			varying vec3 vNormal;
			uniform float time;
			uniform vec2 u_mouse;
			void main() {
			  vUv = uv;
			  vNormal = normal;
			  vPosition = position;
					  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				  }
		  </script>
		  <script id="fragmentShader2" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying vec3 vPosition;
			varying vec3 vNormal;
			uniform float time;
			uniform vec2 u_mouse;

			void main() {
				vec3 color1 = vec3(0.149,0.141,0.912);
				vec3 color2 = vec3(1.000,0.833,0.224);


		//	vec3 color1 = vec3(0.336,0.032,0.215);
			//	vec3 color2 = vec3(0.005,0.004,0.001);


			//vec3 color1 = vec3(0.220,0.021,0.141);
			//	vec3 color2 = vec3(0.005,0.004,0.001);

				gl_FragColor = vec4(mix(color1, color2, vUv.y), 1.0);
			}
		  </script>

		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}

		</script>


		<script id="vertexShader3" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform float width;
			uniform float height;
			uniform vec3 color1;
			uniform vec3 color2;
			void main() {
			  vUv = uv;
			  vNormal = normal;
			  newposition = position;
			  x = position.x / 250.0;
			  y = position.y / 250.0;
	  
			 // newposition.z += 1.05*sin(newposition.y*20. + random + newposition.x*random*0.05);
					  gl_Position = projectionMatrix * modelViewMatrix * vec4(newposition, 1.0);
				  }
		  </script>
		  <script id="fragmentShader3" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			 varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform vec3 color1;
			uniform vec3 color2;
			float plot(vec2 coord, float pct){
			  return  smoothstep( pct-0.260, pct, coord.y) -
					  smoothstep( pct, pct+0.068, coord.y);
			}
			void main() {
			vec2 coord = vUv.xy;
			vec3 color = vec3(0.0);
	  
	  
	  
			//color = mix(color1, color2, 2.3 -  vUv.y*1.25);
			color = mix(color1, color2, 1.7 -  vUv.y*2.5);
	  
	  
			gl_FragColor = vec4(color, 1.0);
	  
			
	  
	  
	  
		
	  
			}
		  </script>



		  
		<script id="vertexShader4" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform float width;
			uniform float height;
			uniform vec3 color1;
			uniform vec3 color2;
			void main() {
			  vUv = uv;
			  vNormal = normal;
			  newposition = position;
			  x = position.x / 250.0;
			  y = position.y / 250.0;
	  
			 // newposition.z += 1.05*sin(newposition.y*20. + random + newposition.x*random*0.05);
					  gl_Position = projectionMatrix * modelViewMatrix * vec4(newposition, 1.0);
				  }
		  </script>
		  <script id="fragmentShader4" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying vec3 newposition;
			varying vec3 vNormal;
			varying float x;
			 varying float y;
			uniform float time;
			uniform float random;
			uniform vec2 u_mouse;
			uniform vec2 u_resolution;
			uniform vec3 color1;
			uniform vec3 color2;
			float plot(vec2 coord, float pct){
			  return  smoothstep( pct-0.260, pct, coord.y) -
					  smoothstep( pct, pct+0.068, coord.y);
			}
			void main() {
			vec2 coord = vUv.xy;
			vec3 color = vec3(0.0);
	  
	  
	  
			//color = mix(color1, color2, 2.3 -  vUv.y*1.25);
			color = mix(color1, color2, 1.7 -  vUv.y*2.5);
	  
	  
			gl_FragColor = vec4(color, 1.0);
	  
			
	  
	  
	  
		
	  
			}
		  </script>
		  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.0/gsap.min.js"></script>
		<script type="module">

			import * as THREE from 'https://threejs.org/build/three.module.js';

			import { GUI } from 'https://threejs.org/examples/jsm/libs/dat.gui.module.js';

			import { OrbitControls } from 'https://threejs.org/examples/jsm/controls/OrbitControls.js';
			import { EffectComposer } from 'https://threejs.org/examples/jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from 'https://threejs.org/examples/jsm/postprocessing/RenderPass.js';
			import { ShaderPass } from 'https://threejs.org/examples/jsm/postprocessing/ShaderPass.js';
			import { UnrealBloomPass } from 'https://threejs.org/examples/jsm/postprocessing/UnrealBloomPass.js';
			import { GLTFLoader } from 'https://threejs.org/examples/jsm/loaders/GLTFLoader.js';

			const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;
			let analyser;
			let sizeVal = 0;

			const bloomLayer = new THREE.Layers();
			bloomLayer.set( BLOOM_SCENE );
			let sphere;
			let movableObjs = [];
			let uniforms2, uniforms3, uniforms4, sphere_a;
			let bottle2, bottle3, orbit, pointlight3, mediaElement;
			const clock = new THREE.Clock();
			const mouse = new THREE.Vector2();
			const target = new THREE.Vector2();
			const windowHalf = new THREE.Vector2( window.innerWidth / 2, window.innerHeight / 2 );
			const params = {
				exposure: 1,
				bloomStrength: 0.5,
				bloomThreshold: 0,
				bloomRadius: 0,
				scene: "Scene only"
			};

			const darkMaterial = new THREE.MeshBasicMaterial( { color: "black" } );
			const materials = {};

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.toneMapping = THREE.ReinhardToneMapping;
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.body.appendChild( renderer.domElement );

			const scene = new THREE.Scene();

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
			// camera.position.set( 0, 0, 20 );
			camera.position.set(0, 0.6, -28);
			camera.position.z = 25;
			camera.lookAt( 0, 0, 0 );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 100;
			controls.enablePan = false;
			controls.enableZoom = true;
			controls.minPolarAngle = (Math.PI / 2) - 0.1; // radians
		  		controls.maxPolarAngle = (Math.PI / 2) - 0.1; // radians
			controls.target.set(0,0,0);
			controls.enableDamping = true;
			//controls.dampingFactor =  0.05;
			controls.dampingFactor =  0.01;
			
			controls.addEventListener( 'change', render );
			controls.update();	
			// scene.add( new THREE.AmbientLight( 0x404040, 1 ) );

			const light = new THREE.AmbientLight( 0x404040, 3 ); // soft white light
			scene.add( light );

			const renderScene = new RenderPass( scene, camera );

			const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
			bloomPass.threshold = params.bloomThreshold;
			bloomPass.strength = params.bloomStrength;
			bloomPass.radius = params.bloomRadius;

			const bloomComposer = new EffectComposer( renderer );
			bloomComposer.renderToScreen = false;
			bloomComposer.addPass( renderScene );
			bloomComposer.addPass( bloomPass );

			const finalPass = new ShaderPass(
				new THREE.ShaderMaterial( {
					uniforms: {
						baseTexture: { value: null },
						bloomTexture: { value: bloomComposer.renderTarget2.texture }
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					defines: {}
				} ), "baseTexture"
			);
			finalPass.needsSwap = true;

			const finalComposer = new EffectComposer( renderer );
			finalComposer.addPass( renderScene );
			finalComposer.addPass( finalPass );

			const raycaster = new THREE.Raycaster();


			// window.addEventListener( 'pointerdown', onPointerDown );
			// window.addEventListener( 'mousemove', onPointerDown );

			const gui = new GUI();

			gui.add( params, 'scene', [ 'Scene with Glow', 'Glow only', 'Scene only' ] ).onChange( function ( value ) {

				switch ( value ) 	{

					case 'Scene with Glow':
						bloomComposer.renderToScreen = false;
						break;
					case 'Glow only':
						bloomComposer.renderToScreen = true;
						break;
					case 'Scene only':
						// nothing to do
						break;

				}

				render();

			} );

			const folder = gui.addFolder( 'Bloom Parameters' );

			folder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {

				renderer.toneMappingExposure = Math.pow( value, 4.0 );
				render();

			} );

			folder.add( params, 'bloomThreshold', 0.0, 1.0 ).onChange( function ( value ) {

				bloomPass.threshold = Number( value );
				render();

			} );

			folder.add( params, 'bloomStrength', 0.0, 10.0 ).onChange( function ( value ) {

				bloomPass.strength = Number( value );
				render();

			} );

			folder.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

				bloomPass.radius = Number( value );
				render();

			} );

			setupScene();

			// function onPointerDown( event ) {

			// 	event.preventDefault();

			// 	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			// 	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			// 	raycaster.setFromCamera( mouse, camera );
			// 	const intersects = raycaster.intersectObjects( scene.children );
			// 	if ( intersects.length > 0 ) {

			// 		const object = intersects[ 0 ].object;
			// 		// object.layers.toggle( BLOOM_SCENE );
			// 			object.layers.enable( BLOOM_SCENE );
			// 		render();

			// 	}

			// }

			window.onresize = function () {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

				bloomComposer.setSize( width, height );
				finalComposer.setSize( width, height );
				windowHalf.set( width / 2, height / 2 );

				render();

			};

			function setupScene() {

				scene.traverse( disposeMaterial );
				scene.children.length = 0;
				setTimeout(() => {
					
				
				const listener = new THREE.AudioListener();

				const audio = new THREE.Audio( listener );
				const file = './metatron.mp3';

				if ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) {

					const loader = new THREE.AudioLoader();
					loader.load( file, function ( buffer ) {
						audio.setRefDistance( 2000 );
						audio.setBuffer( buffer );
						// audio.setLoop(true);
					//	audio.setRefDistance(2000);
						document.addEventListener("click", () => {
			
							
						
				})
					} );

				} else {

					mediaElement = new Audio( file );
				
						
					
					document.addEventListener("click", () => {
					
					mediaElement.play();	
					// mediaElement.resume();	
				})
					

					audio.setMediaElementSource( mediaElement );

				}
				audio.hasPlaybackControl = true;
				document.addEventListener("click", () => {
					audio.play();
				//	audio.noteOn();
					//audio.start();
							var source = listener.context.createBufferSource();
				source.connect(listener.context.destination);
				source.start();
					// console.log(audio)
					
						
				})
				analyser = new THREE.AudioAnalyser( audio, 32768 );
			}, 1000);
				

			// function playSound() {
			// 	audioLoader.load("clips/theme_80.mp3", function(buffer) {
			// 		sound.setBuffer( buffer );
			// 		sound.setRefDistance( 20 );
			// 		sound.play();
			// 	});

			// 	var source = listener.context.createBufferSource();
			// 	source.connect(listener.context.destination);
			// 	source.start();
			// 	}
			// 	window.addEventListener('touchstart', playSound);
			// 	document.addEventListener('click', playSound);

				// setInterval(() => {
				// 	// console.log(Math.max(...analyser.data))
				// 	console.log(sizeVal)
				// 	// sizeVal = Math.max(...analyser.data);
				
				// 	// console.log(analyser)
				// }, 100);

				

				




				const geometry = new THREE.SphereGeometry( 0.2, 32, 32 );
				uniforms3 = {
						time: {value: 0},
						u_mouse: { type: "v2", value: new THREE.Vector2() },
						u_resolution: { type: "v2", value: new THREE.Vector2() },
						color1: { type: "c", value: new THREE.Color(0xFFD225)  },
						color2: { type: "c", value: new THREE.Color(0xff760f)  },
						width: {
							type: "f",
							value: window.innerWidth
						},
						height: {
							type: "f",
							value: window.innerHeight
						},
						random: {
						value: Math.random()*2.5
						}
						};
				for ( let i = 0; i < 150; i ++ ) {
					
					// const color = new THREE.Color();
					// color.setHSL( Math.random(), 0.8, Math.random() * 0.2 + 0.05 );

					const material = new THREE.ShaderMaterial({
          side: THREE.DoubleSide,
          uniforms: uniforms3,
          vertexShader: document.getElementById("vertexShader3").textContent,
          fragmentShader: document.getElementById("fragmentShader3").textContent,
        });
					
					sphere = new THREE.Mesh( geometry, material );
			// // numbers between 20-60		Math.random() * (60 - 20) + 20;
			// 		sphere.position.x = -Math.floor(Math.random() * 6) + 100; 
			// 		sphere.position.y = Math.floor(Math.random() * 20); 
			// 		sphere.position.z = Math.random() * 30;
			// 		sphere.position.normalize().multiplyScalar( Math.random() * 400 );
			// 		// sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
			
			sphere.position.x = Math.random() * 10 - 5;
					sphere.position.y = Math.random() * 10 - 5;
					sphere.position.z = Math.random() * 10 - 5;
					sphere.position.normalize().multiplyScalar( Math.random() * 30.0 + 8.0 );
					sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
					sphere.castShadow = false; //default is false
					sphere.receiveShadow = false; //default
					// sphere.material.specular.setHex(0x000000);
					scene.add( sphere );
					movableObjs.push(sphere);
					// console.log(movableObjs)
					// console.log(scene.children)
					sphere.layers.enable( BLOOM_SCENE );

				}




				
				const geometry_a = new THREE.SphereGeometry( 0.2, 32, 32 );
				uniforms4 = {
						time: {value: 0},
						u_mouse: { type: "v2", value: new THREE.Vector2() },
						u_resolution: { type: "v2", value: new THREE.Vector2() },
						color1: { type: "c", value: new THREE.Color(0xff2596)  },
						color2: { type: "c", value: new THREE.Color(0x57063d)  },
						width: {
							type: "f",
							value: window.innerWidth
						},
						height: {
							type: "f",
							value: window.innerHeight
						},
						random: {
						value: Math.random()*2.5
						}
						};
				for ( let i = 0; i < 150; i ++ ) {
					
					// const color = new THREE.Color();
					// color.setHSL( Math.random(), 0.8, Math.random() * 0.2 + 0.05 );

					const material_a = new THREE.ShaderMaterial({
          side: THREE.DoubleSide,
          uniforms: uniforms4,
          vertexShader: document.getElementById("vertexShader4").textContent,
          fragmentShader: document.getElementById("fragmentShader4").textContent,
        });
					
					sphere_a = new THREE.Mesh( geometry_a, material_a );
			// // numbers between 20-60		Math.random() * (60 - 20) + 20;
			// 		sphere.position.x = -Math.floor(Math.random() * 6) + 100; 
			// 		sphere.position.y = Math.floor(Math.random() * 20); 
			// 		sphere.position.z = Math.random() * 30;
			// 		sphere.position.normalize().multiplyScalar( Math.random() * 400 );
			// 		// sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
			
			sphere_a.position.x = Math.random() * 10 - 5;
					sphere_a.position.y = Math.random() * 10 - 5;
					sphere_a.position.z = Math.random() * 10 - 5;
					sphere_a.position.normalize().multiplyScalar( Math.random() * 30.0 + 8.0 );
					sphere_a.scale.setScalar( Math.random() * Math.random() + 0.5 );
					sphere_a.castShadow = false; //default is false
					sphere_a.receiveShadow = false; //default
					// sphere.material.specular.setHex(0x000000);
					scene.add( sphere_a );
					movableObjs.push(sphere_a);
					// console.log(movableObjs)
					// console.log(scene.children)
					sphere_a.layers.enable( BLOOM_SCENE );

				}

				// var radius = 10;
				// var turns = 3;
				// var objPerTurn = 30;

				// var angleStep = (Math.PI * 2) / objPerTurn;
				// var heightStep = 0.5;

				// var geom = new THREE.SphereGeometry(0.5, 50, 50);

				// for (let i = 0; i < turns * objPerTurn; i++) {
				// let plane = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({
				// 	color: Math.random() * 0x888888 + 0x888888
				// }));

				// // position
				// plane.position.set(
				// 	Math.cos(angleStep * i) * radius,
				// 	heightStep * i,
				// 	Math.sin(angleStep * i) * radius
				// );

				// // rotation
				// plane.rotation.y = -angleStep * i;

				// scene.add(plane);
				// plane.layers.enable( BLOOM_SCENE );
				// }
				var geometryplane = new THREE.SphereGeometry(80, 80, 200);

						uniforms2 = {
						time: {value: 0},
						u_mouse: { type: "v2", value: new THREE.Vector2() },
						};

						var materialplane = new THREE.ShaderMaterial({
						// side: THREE.DoubleSide,
						side: THREE.BackSide,
						uniforms: uniforms2,
						vertexShader: document.getElementById("vertexShader2").textContent,
						fragmentShader: document.getElementById("fragmentShader2").textContent,
						});

						var mesh2 = new THREE.Mesh(geometryplane, materialplane);
						scene.add(mesh2);
						const light = new THREE.AmbientLight( 0xF8F3F8 ); // soft white light
						scene.add( light );

					const pointLight = new THREE.PointLight( 0x00FDFD, 3, 700 );
					pointLight.position.set( 6, 2, 0 );
					scene.add( pointLight );

			



					const pointlight2 = new THREE.PointLight(0xF82888, 3, 700);
					pointlight2.position.set(-6, 2, 5);
				//	pointlight2.add( new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0xff0000 } ) ) );
					scene.add(pointlight2);

				// 	const pointlight5 = new THREE.PointLight(0x00FDFD, 3, 700);
				// 	pointlight5.position.set(0, 2, -15);
				// //	pointlight2.add( new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0xff0000 } ) ) );
				// 	scene.add(pointlight5);
			

					// pointlight3 = new THREE.PointLight(0xF82888, 4.5, 5200);
					// pointlight3.position.set(0, 10, 20);
					// scene.add(pointlight3);
				
					// const pointlight4 = new THREE.PointLight(0x00FDFD, 2.5, 5200);
					// pointlight4.position.set(0, 10, -20);
					// scene.add(pointlight4);

					// const pointlight4 = new THREE.PointLight(0xFFA500, 1.5, 2200);
					// pointlight4.position.set(20, 0, 90);
					// scene.add(pointlight4);

					const sphereSize = 1;
					const pointLightHelper = new THREE.PointLightHelper( pointlight2, sphereSize );
					scene.add( pointLightHelper );
					const pointLightHelper2 = new THREE.PointLightHelper( pointLight, sphereSize );
					scene.add( pointLightHelper2 );
					// const pointLightHelper3 = new THREE.PointLightHelper( pointlight3, sphereSize );
					// scene.add( pointLightHelper3 );
					// const pointLightHelper4 = new THREE.PointLightHelper( pointlight4, sphereSize );
					// scene.add( pointLightHelper4 );
						
					// const pointLightHelper5 = new THREE.PointLightHelper( pointlight5, sphereSize );
					// scene.add( pointLightHelper5 );
						
						const loader = new GLTFLoader().setPath("./glbbottle/");
							loader.load("scene.glb", function (gltf) {
								bottle2 = gltf.scene;
								bottle2.rotation.y = -5.2;
								bottle2.position.y = -8.4;
								bottle2.position.x = -2.7;
								bottle2.traverse(function (child) {
								if (child.isMesh) {
								}
								});
								bottle2.scale.set(50,50,50);
								scene.add(bottle2);
								console.log(bottle2)
								render();
							});

							loader.load("scene.glb", function (gltf) {
								bottle3 = gltf.scene;
								bottle3.rotation.y = -0.1;
								bottle3.rotation.z = -0.2;


								bottle3.position.y = -8.3;
								bottle3.position.z = -2.7;

								
								bottle3.position.x = 1.2 - 2.7;
								bottle3.traverse(function (child) {
								if (child.isMesh) {
								}
								});
								bottle3.scale.set(50,50,50);
								scene.add(bottle3);
								// console.log(bottle3)
								
							});
							console.log(uniforms3.color1.value.g)
				render();

			}

			// document.addEventListener('mousemove', function(e){
    		// 	// let scale = -0.01;
			// 	// 	orbit.rotateY( e.movementX / 500 );
			// 	// // orbit.rotateX( e.movementY * scale ); 
			// 	// orbit.rotation.z = 0; //this is important to keep the camera level..
			// 	// camera.position.x = e.movementX / 900;
			// 	// camera.updateProjectionMatrix();
			// 	mouse.x = ( e.clientX - windowHalf.x );
			// 	mouse.y = ( e.clientY - windowHalf.y );
				
			// 	})
				
				// //the camera rotation pivot
				// orbit = new THREE.Object3D();
				// orbit.rotation.order = "YXZ"; //this is important to keep level, so Z should be the last axis to rotate in order...
				// if(bottle2) orbit.position.copy( bottle2.position );
				// scene.add(orbit );
				// orbit.add( camera );




			function disposeMaterial( obj ) {

				if ( obj.material ) {

					obj.material.dispose();

				}

			}

			function render() {
				const time = Date.now() * 0.0001;
				
				switch ( params.scene ) {

					case 'Scene only':
						renderer.render( scene, camera );
						break;
					case 'Glow only':
						renderBloom( false );
						break;
					case 'Scene with Glow':
					default:
						// render scene with bloom
						renderBloom( true );

						// render the entire scene, then render bloom scene on top
						finalComposer.render();
						break;

				}
				// pointlight3.position.x = Math.cos( time * 20.7 ) * 285;
				for (let i = 0; i < movableObjs.length; i++) {
			
					// const sphere = movableObjs[ i ];
					// sphere.position.x = Math.cos( time + i * 100.7 ) * 11;
					// sphere.position.y = Math.sin( time + i * 3.1 ) * 11;
					// sphere.position.z = Math.sin( time + i * 1.1 ) * 15;
			
					
				}
			
				

			}

			function renderBloom( mask ) {

				if ( mask === true ) {

					scene.traverse( darkenNonBloomed );
					bloomComposer.render();
					scene.traverse( restoreMaterial );

				} else {

					camera.layers.set( BLOOM_SCENE );
					bloomComposer.render();
					camera.layers.set( ENTIRE_SCENE );

				}

			}

			function darkenNonBloomed( obj ) {

				if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

					materials[ obj.uuid ] = obj.material;
					obj.material = darkMaterial;

				}

			}

			function restoreMaterial( obj ) {

				if ( materials[ obj.uuid ] ) {

					obj.material = materials[ obj.uuid ];
					delete materials[ obj.uuid ];

				}

			}
			var animate = function () {
        requestAnimationFrame(animate);
		if(analyser)	analyser.getFrequencyData();
				// sphere.rotation.x += 50;
				// target.x = ( 1 - mouse.x ) * 0.0001;
				// target.y = ( 1 - mouse.y ) * 0.0001;
				
				// camera.rotation.x += 0.13 * ( target.y - camera.rotation.x );
				// camera.rotation.y += 0.13 * ( target.x - camera.rotation.y );

				uniforms2.time.value += clock.getDelta();
			
				if(analyser)	sizeVal = Math.max(...analyser.data) / 80;

				if(sizeVal < 3.1 && sizeVal > 3.05){
			
					// uniforms4.color1.value = new THREE.Color(0xff2596);
					// uniforms4.color2.value = new THREE.Color(0x57063d);
							uniforms3.color1.value = new THREE.Color(0xFFD225 );
					uniforms3.color2.value = new THREE.Color(0xff760f);
				} 
				
				
			else if(sizeVal < 3.04 && sizeVal > 3.00){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}
				else if(sizeVal < 3.1 && sizeVal > 3.07){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}
				
				
				else if(sizeVal < 2.8 && sizeVal > 2.5){
					// uniforms4.color1.value = new THREE.Color(0xff2596);
					// uniforms4.color2.value = new THREE.Color(0x57063d);
							uniforms3.color1.value = new THREE.Color(0xFFD225 );
					uniforms3.color2.value = new THREE.Color(0xff760f);
				}

				else if(sizeVal < 2.5 && sizeVal > 2.2){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}

				else if(sizeVal < 2.1 && sizeVal > 1.8){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}

				else if(sizeVal < 1.8 && sizeVal > 1.3){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}
				
				else if(sizeVal < 1.3 && sizeVal > 1.2){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}


				

				else if(sizeVal < 1.1 && sizeVal > 0.9){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}

				else if(sizeVal < 0.8 && sizeVal > 0.5){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}

				else if(sizeVal < 0.4 && sizeVal > 0.2){
					uniforms4.color1.value = new THREE.Color(0xff2596);
					uniforms4.color2.value = new THREE.Color(0x57063d);
					// 		uniforms3.color1.value = new THREE.Color(0xFFD225 );
					// uniforms3.color2.value = new THREE.Color(0xff760f);
				}


				
			
				
				else{
					gsap.to(uniforms4.color1.value, {
						duration: 0.8,
						// value: new THREE.Color(0x5c5c5c),
						r: 0.376,
						g: 0.294,
						b: 0.412,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})

					gsap.to(uniforms4.color2.value, {
						duration: 0.8,
						r: 0.169,
						g: 0.169,
						b: 0.169,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})

					gsap.to(uniforms3.color1.value, {
						duration: 0.8,
						r: 0.361,
						g: 0.361,
						b: 0.02,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})

					gsap.to(uniforms3.color2.value, {
						duration: 0.8,
						r: 0.169,
						g: 0.169,
						b: 0.169,
					
						onUpdate: function() {
					// camera.updateProjectionMatrix;
					// controls.update();
					
					}
										
					})




					// uniforms4.color1.value = new THREE.Color(0x5c5c5c);
					// uniforms4.color2.value = new THREE.Color(0x2b2b2b);
						// uniforms3.color1.value = new THREE.Color(0x5c5c5c);
					// uniforms3.color2.value = new THREE.Color(0x2b2b2b);
				}


			
				
				controls.update();
				render();

			}
			animate();

		</script>

	</body>

</html>
